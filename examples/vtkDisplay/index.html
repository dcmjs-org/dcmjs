<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">

    <link href="../css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<div class="container">
    <div class="page-header">
        <h1>
            Display DICOM Segmentation with VTK-JS
        </h1>
        <p>
            This example demonstrates how to display a DICOM Segmentation object with vtk-js.
        </p>
        <a href="../index.html">Go back to the Examples page</a>
    </div>

    <div class="row">
        <button id="sampleData">Get Sample Data</button><p id="statusLine"></p>
        <div class="col-xs-6">
            <div style="width:512px;height:512px;position:relative;display:inline-block;"
                 oncontextmenu="return false"
                 unselectable='on'
                 onselectstart='return false;'
                 onmousedown='return false;'>
                <div id="dicomImage"
                     style="width:512px;height:512px;top:0px;left:0px; position:absolute;">
                </div>
            </div>

            <p>Sample data is from the dicom4qi connectathon event to be held at RSNA 2017.  This is <a href='https://qiicr.gitbooks.io/dicom4qi/content/instructions/seg.html#test-dataset-2'>test dataset #2</a>
        </div>
        <div class="col-xs-6">
            <div id="properties">
            </div>
        </div>
    </div>
</div>
</body>

<script src="../js/jquery.min.js"></script>
<script src="../js/jqueryFileDrop.js"></script>

<script src="../helpers/DICOMZero.js"></script>

<script src="../../build/dcmjs.js"></script>

<script type="text/javascript" src="https://unpkg.com/vtk.js"></script>

<script>
  let element;
  let volumeViewer;
  let vtkVolumeActors = [];
  let controllerWidgets = [];

  $(document).ready(function() {

    element = document.getElementById('dicomImage');

    volumeViewer = vtk.Rendering.Misc.vtkGenericRenderWindow.newInstance({
        background: [0, 0, 0],
    });
    const renderWindow = volumeViewer.getRenderWindow();
    const renderer = volumeViewer.getRenderer();

    element.innerHTML = '';
    volumeViewer.setContainer(element);

    // TODO: VTK's canvas currently does not fill the viewport element
    // after it has been resized. We need to set the height to 100% and
    // trigger volumeViewer.resize() whenever things are resized.
    // We might need to find a way to hook onto the OHIF Viewer ResizeManager
    // div.querySelector('canvas').style.height = '100%';
    volumeViewer.resize();



    //
    // generic promisified XMLHttpRequest
    // based on https://stackoverflow.com/questions/30008114/how-do-i-promisify-native-xhr
    //
    function makeRequest (options) {
      return new Promise(function (resolve, reject) {
        options.method = options.method || "GET";
        if (!options.url) {
          reject({
            status: 404,
            statusText: "need a url to request"
          });
        }
        var xhr = new XMLHttpRequest();
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        xhr.open(options.method, options.url);
        xhr.onload = function () {
          if (this.status >= 200 && this.status < 300) {
            resolve(xhr.response);
          } else {
            reject({
              status: this.status,
              statusText: xhr.statusText
            });
          }
        };
        xhr.onerror = function () {
          reject({
            status: this.status,
            statusText: xhr.statusText
          });
        };
        if (options.headers) {
          Object.keys(options.headers).forEach(function (key) {
            xhr.setRequestHeader(key, options.headers[key]);
          });
        }
        var params = options.params;
        // We'll need to stringify if we've been given an object
        // If we have a string, this is skipped.
        if (params && typeof params === 'object') {
          params = Object.keys(params).map(function (key) {
            return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
          }).join('&');
        }
        xhr.send(params);
      });
    }

    // uses dataset for common elements but perFrame to override
    // (for multiple segments)
    function geometryFromFunctionalGroups(dataset, perFrame) {
      const vtkMath = vtk.Common.Core.vtkMath;
      let pixelMeasures = dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;
      let planeOrientation = dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;
      let planePosition = perFrame[0].PlanePositionSequence; // TODO: assume sorted frames!

      const geometry = {};

      // NB: DICOM PixelSpacing is defined as Row then Column,
      // unlike ImageOrientationPatient
      geometry.spacing = [pixelMeasures.PixelSpacing[1],
                          pixelMeasures.PixelSpacing[0],
                          pixelMeasures.SpacingBetweenSlices].map(Number);

      geometry.dimensions = [dataset.Columns,
                             dataset.Rows,
                             perFrame.length].map(Number);

      let orientation = planeOrientation.ImageOrientationPatient.map(Number);
      const columnStepToPatient = orientation.slice(0,3);
      const rowStepToPatient = orientation.slice(3,6);
      const planeNormal = [];
      vtkMath.cross(columnStepToPatient, rowStepToPatient, planeNormal);

      let firstPosition = perFrame[0].PlanePositionSequence.ImagePositionPatient.map(Number);
      let lastPosition = perFrame[perFrame.length-1].PlanePositionSequence.ImagePositionPatient.map(Number);
      geometry.sliceStep = [];
      vtkMath.subtract(lastPosition, firstPosition, geometry.sliceStep);
      vtkMath.normalize(geometry.sliceStep);


                               // TODO vtk requires orthonormal directions
                               // which could mean we need to shuffle the data

      geometry.direction = columnStepToPatient.concat(rowStepToPatient).concat(planeNormal);

      geometry.origin = planePosition.ImagePositionPatient.map(Number);

      console.log(geometry);

      return(geometry);
    }

    //
    // takes the arraybuffer of dicom data and returns
    // a vtkVolume (actor) ready to render
    //
    function part10ToVolumeActor(part10) {

      dataset = DICOMZero.datasetFromArrayBuffer(part10);

      const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({
          name: "Scalars",
          numberOfComponents: dataset.SamplesPerPixel,
          values: new Int16Array(dataset.PixelData),
      });

      const imageData = vtk.Common.DataModel.vtkImageData.newInstance();
      imageData.getPointData().setScalars(scalarArray);

      geometry = geometryFromFunctionalGroups(dataset, dataset.PerFrameFunctionalGroupsSequence);
      imageData.setDimensions(geometry.dimensions);
      imageData.setSpacing(geometry.spacing);
      imageData.setOrigin(geometry.origin);
      imageData.setDirection(geometry.direction);

      const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();
      mapper.setInputData(imageData);
      mapper.setSampleDistance(2.);

      const actor = vtk.Rendering.Core.vtkVolume.newInstance();
      actor.setMapper(mapper);

      return actor;
    }

    function part10ToSEGVolumeActors(part10) {
      const segments = {};

      dataset = DICOMZero.datasetFromArrayBuffer(part10);
      dataset.SegmentSequence.forEach(segment => {

        // TODO: other interesting fields could be extracted from the segment

        // color for making the lookup table
        const cielab = segment.RecommendedDisplayCIELabValue;
        const rgba = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));
        rgba.push(255);

        segments[segment.SegmentNumber] = {
          color: rgba,
          functionalGroups: [],
          offset: null,
          size: null,
          pixelData: null,
        }

      });

      // make a list of functional groups per segment
      dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {
        let segmentNumber = functionalGroup.SegmentIdentificationSequence.ReferencedSegmentNumber;
        segments[segmentNumber].functionalGroups.push(functionalGroup);
      });

      // determine per-segment index into the pixel data
      // TODO: only handles one-bit-per pixel
      const actors = [];
      let frameSize = Math.ceil(dataset.Rows * dataset.Columns / 8);
      let nextOffset = 0;
      Object.keys(segments).forEach(segmentKey => {
        const segment = segments[segmentKey];
        segment.numberOfFrames = segment.functionalGroups.length;
        segment.size = segment.numberOfFrames * frameSize;
        segment.offset = nextOffset;
        nextOffset  = segment.offset + segment.size
        const packedSegment = dataset.PixelData.slice(segment.offset, nextOffset);
        segment.pixelData = dcmjs.data.BitArray.unpack(packedSegment);

        // now make actors using the segment information
        const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({
            name: "Scalars",
            numberOfComponents: 1,
            values: segment.pixelData,
        });

        const imageData = vtk.Common.DataModel.vtkImageData.newInstance();
        imageData.getPointData().setScalars(scalarArray);

        geometry = geometryFromFunctionalGroups(dataset, segment.functionalGroups);
        imageData.setDimensions(geometry.dimensions);
        imageData.setSpacing(geometry.spacing);
        imageData.setOrigin(geometry.origin);
        imageData.setDirection(geometry.direction);

        const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();
        mapper.setInputData(imageData);
        mapper.setSampleDistance(2.);

        const actor = vtk.Rendering.Core.vtkVolume.newInstance();
        actor.setMapper(mapper);

        actors.push(actor);
      });

      return(actors);
    }

    function downloadAndDisplaySampleData() {

      const urlRoot = 'https://s3.amazonaws.com/IsomicsPublic/SampleData/rsna2017/seg/task2/'
      const petURL = urlRoot + 'PT-multiframe.dcm';
      const segURL = urlRoot + 'SEG/tumor_User1_Manual_Trial1.dcm';

      var petPromise = makeRequest({url: petURL, responseType: "arraybuffer"});
      var segPromise = makeRequest({url: segURL, responseType: "arraybuffer"});

      //
      // once the images have been loaded
      //
      Promise.all([petPromise, segPromise]).then(values => {
        const petPart10 = values[0];
        const segPart10 = values[1];

        vtkVolumeActors.push(part10ToVolumeActor(petPart10));

        const segActors = part10ToSEGVolumeActors(segPart10);
        vtkVolumeActors = vtkVolumeActors.concat(segActors);

        vtkVolumeActors.forEach(volume => {

          renderer.addVolume(volume);

          const controllerWidget = vtk.Interaction.UI.vtkVolumeController.newInstance({
            size: [400, 150],
            rescaleColorMap: true,
          });
          controllerWidgets.push(controllerWidget);

          const properties = document.getElementById('properties');
          const volumeDiv = document.createElement('div');
          properties.appendChild(volumeDiv);
          controllerWidget.setContainer(volumeDiv);
          controllerWidget.setupContent(renderWindow, volume, isBackgroundDark=true, useShadow=false, presetName='Grayscale');
          controllerWidget.onModified();
          //volume.getProperty().getRGBTransferFunction(0).setMappingRange([0,500]); // TODO - fix default lookup table
          const volumeControlContainer = volumeDiv.querySelector('div[class^=VolumeController-container]');
          volumeControlContainer.style.position = 'inherit';

        });
        renderer.resetCamera();
        renderer.getActiveCamera().zoom(1.5);
        renderer.getActiveCamera().elevation(70);
        renderer.updateLightsGeometryToFollowCamera();
        renderWindow.render();

        $('p#statusLine').text("");
      });

    }

    // Select the right layer in the dropdown
    function updateSelectedLayer(layerId) {
      var $layers = $('#layers');
      var currentLayerId = $layers.val();

      if(currentLayerId !== layerId) {
        $layers.val(layerId);
        $layers.trigger('change');
      }
    }

    // Listen to `change` event to update the opacity of the active layer
    $("#imageOpacity").on('input',function(event) {
      var layer = cornerstone.getActiveLayer(element);
      layer.options.opacity = parseFloat(event.currentTarget.value);
      cornerstone.updateImage(element);
    });

    // Listen to `change` event to update the visibility of the active layer
    $('input[name=visible]').change(function(event) {
      var layer = cornerstone.getActiveLayer(element);
      layer.options.visible = (event.currentTarget.value === "1");
      cornerstone.updateImage(element);
    });

    // This event will be called every time a layer is added through cornerstone.addLayer
    // The layer is added to the dropdown to make it possible to select and interact with it
    $(element).on('CornerstoneLayerAdded', function(e, eventData) {
      var layer = cornerstone.getLayer(eventData.element, eventData.layerId);
      var $layers = $('#layers');
      var $layerOption = $('<option></option>')
        .val(layer.layerId)
        .text(layer.options.name);

      // Set the layer as selected in case its the the first layer to be added
      if($layers.children().length === 0) {
        $layerOption.prop('selected', true);
      }

      $layers.append($layerOption);
    });

    // This event will be called every time cornerstone.setActiveLayer is called
    // We need to load the layer properties and update the selected layer in the dropdown
    $(element).on('CornerstoneActiveLayerChanged', function(e, eventData) {
      var layer = cornerstone.getActiveLayer(element);
      var opacity = layer.options.opacity == null ? 1 : layer.options.opacity;
      var visible = layer.options.visible !== false ? 1 : 0;

      // Restore all properties for the active layer
      $('#imageOpacity').val(opacity);
      $("input[name=visible][value=" + visible + "]").prop('checked', true);

      updateSelectedLayer(eventData.layerId);
    });

    $('#sampleData').click(function(event) {
      $('p#statusLine').text("Downloading...");
      downloadAndDisplaySampleData();
    });


    window.addEventListener('resize', function() {
      console.log('need to resize the vtk window');
    });
    window.dispatchEvent(new Event('resize'));

  });
</script>
</html>
